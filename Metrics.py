# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-Jgj-zSWeNf5cdZ9uGULWE0QHtbppNwu
"""

!pip install transformers

from google.colab import drive
drive.mount('/content/drive')

!mkdir "test"
!tar -xzvf /content/drive/MyDrive/myProjects/cv-corpus-12.0-delta-2022-12-07-en.tar.gz -C "test"

from transformers import pipeline, WhisperFeatureExtractor, WhisperTokenizer, WhisperProcessor
import torch
path = "Tesseract3D/LMT2-Tuned-S"

# transfer model

pipe = pipeline(model=path, device=torch.device("cuda:0" if torch.cuda.is_available() else "cpu"))


FE = WhisperFeatureExtractor.from_pretrained(path)
tokenizer = WhisperTokenizer.from_pretrained(path)
model = WhisperProcessor.from_pretrained(path)
def transcribe(audio):
    #text = pipe(audio)["text"]
    #return text
    out = pipe(audio)
    out = tokenizer._tokenize(out["text"])
    f = []
    for o in out:
      f.append(tokenizer._convert_token_to_id(o))
    return np.asarray(f)

import librosa as lr
def LoadAudio(x):
    x, sr = lr.load(x, sr=16000)
    return x

import pandas as pd
import numpy as np
from tqdm import tqdm

df = pd.read_csv('/content/test/cv-corpus-12.0-delta-2022-12-07/en/validated.tsv', sep="\t")

# read the data frame
df.head()

inps = df["path"][:200] #X
outs = df["sentence"][:200] #Y

X = np.array([LoadAudio("/content/test/cv-corpus-12.0-delta-2022-12-07/en/clips/"+x) for x in tqdm(inps, desc='Loading audio files')])

!pip install colorednoise

import colorednoise as cn
def White_noise(x):
  noise_factor = 0.005
  white_noise = np.random.randn(len(x)) * noise_factor
  return  x + white_noise

def Pink_noise(x):
  pink_noise = cn.powerlaw_psd_gaussian(1, len(x))
  return x + pink_noise

def Brown_noise(x):
  brown_noise = cn.powerlaw_psd_gaussian(2, len(x))
  return x + brown_noise

Y = []

for ip in inps:

  y = []
  for i in ip:
      y.append(tokenizer._convert_token_to_id(i))
  Y.append(y)

Y = np.asarray(Y)

Pred = np.array([transcribe(x) for x in X])
WPred = np.array([transcribe(White_noise(x)) for x in X])
PPred = np.array([transcribe(Pink_noise(x)) for x in X])
BPred = np.array([transcribe(Brown_noise(x)) for x in X])

def calculate_metrics(true_words, predicted_words):
    total_words = 0
    error_words = 0
    correct_words = 0

    for true_sentence, predicted_sentence in zip(true_words, predicted_words):
        true_sentence_words = true_sentence
        predicted_sentence_words = predicted_sentence
        total_words += len(true_sentence_words)

        for true_word, predicted_word in zip(true_sentence_words, predicted_sentence_words):
            if true_word != predicted_word:
                error_words += 1
            else:
                correct_words += 1

    wer = (error_words / total_words) * 100
    accuracy = (correct_words / total_words) * 100

    return wer, accuracy
calculate_metrics(Y, WPred)

Pred

